use super::*;

use std::fs;
use std::fs::File;
use std::io::prelude::*;
use std::io::{self, BufRead, LineWriter};
use std::path::Path;

fn add_main(code: String) -> String {
    let mut generator = StringGenerator::from_string(code);
    let mut main_generator = StringGenerator::new();

    main_generator
        .append("// THIS IS AN AUTOGENERATED FILE AND SHOULD NOT BE MODIFIED BY HAND".to_string())
        .add_line()
        .append("use std::collections::HashMap;".to_string())
        .add_lines(2)
        .append("fn main() {".to_string())
        .indent()
        .add_line()
        .append("let mut nioe = Nioe::new();".to_string())
        .add_line()
        .append("nioe.execute();".to_string())
        .add_line();
    main_generator
        .unindent()
        .add_line()
        .append("}".to_string())
        .add_line();

    generator.prepend(main_generator.to_string());

    return generator.to_string();
}

fn generate(ast: &Ast) -> String {
    let mut nioe_output_queues = vec![];
    let mut output_structs = vec![];
    let mut inputless_nodes = vec![];
    let mut triggered_nodes = vec![];
    let mut nodes_refs = vec![];

    match ast {
        Ast::Node(n) => {}
        Ast::Program(nodes) => {
            for node in nodes {
                match node {
                    Ast::Node(n) => {
                        if n.input.is_none() {
                            //wire up inputless node
                            inputless_nodes.push(n.clone());
                        } else {
                            triggered_nodes.push(n.clone());
                        }

                        nodes_refs.push(n.clone());

                        match &n.output {
                            ast::Outputs::References(_, ids) => {
                                for id in ids {
                                    nioe_output_queues.push(id.clone());
                                    output_structs.push(id.clone());
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
    }

    let mut generator = StringGenerator::new();
    // Generate nioe struct/impl
    {
        generator
            .add_line()
            .append("pub struct Nioe {}".to_string())
            .add_line()
            .append("impl Nioe {".to_string())
            .indent()
            .add_line()
            .append("pub fn new() -> Self {".to_string())
            .indent()
            .add_line()
            .append("return Self{".to_string())
            .indent()
            .unindent()
            .add_line()
            .append("};".to_string());

        // Begin execution method
        {
            generator
                .unindent()
                .add_line()
                .append("}".to_string())
                .add_lines(2)
                .append("pub fn execute(&mut self) {".to_string())
                .indent()
                .add_line()
                // Init message storage
                .append("// Init storage".to_string())
                .add_line()
                .append(
                    "let mut storage: HashMap<String, Vec<String>> = HashMap::new();".to_string(),
                )
                .add_lines(2)
                .append("// Init nodes".to_string());

            // Create nodes
            for n in &nodes_refs {
                generator.add_line().append(format!(
                    "let mut {} = {}::new();",
                    alias(&n),
                    n.id.rust()
                ));
            }

            // Trigger execution of inputless nodes
            generator
                .add_lines(2)
                .append("// Begin execution of inputless nodes".to_string());
            for n in inputless_nodes {
                generator
                    .add_line()
                    .append(format!("{}.execute(&mut storage);", alias(&n)));
            }

            // Add a simple 'loop' for processing of messages while they need to be processed
            {
                generator
                    .add_lines(2)
                    .append("// This is the core loop that processes node i/o".to_string())
                    .add_line()
                    .append("while storage.is_empty() == false {".to_string())
                    .indent();
                // For each node, link it up
                for n in triggered_nodes {
                    generator
                        .add_line()
                        .append(format!("{}.execute(&mut storage);", alias(&n)));
                }

                // Close loop
                generator.unindent().add_line().append("}".to_string());
            }

            // Close the brackets
            generator
                .unindent()
                .add_line()
                .append("}".to_string())
                .unindent()
                .add_line()
                .append("}".to_string());
        }
    }

    // Generate node structs
    {
        for node in &nodes_refs {
            generator
                .add_lines(2)
                .append(format!("pub struct {} {{", node.id.rust()))
                .indent();

            // For each input, add a counter so it knows what input position it's on in the storage key
            if node.input.is_some() {
                let input = node.input.as_ref().unwrap();
                match input {
                    ast::Inputs::References(_, reference_ids) => {
                        for signal_ref in reference_ids {
                            generator
                                .add_line()
                                .append(format!("pub {}: usize,", reference_counter(signal_ref)));
                        }
                    }
                }
            }

            generator
                .unindent()
                .add_line()
                .append("}".to_string())
                .add_line()
                // Create the implementation
                .append(format!("impl {} {{", node.id.rust()))
                .indent()
                .add_line()
                .append("pub fn new() -> Self {".to_string())
                .indent()
                .add_line()
                .append("Self {".to_string())
                .indent();
            // For each reference index, initialize it
            if node.input.is_some() {
                let input = node.input.as_ref().unwrap();
                match input {
                    ast::Inputs::References(_, reference_ids) => {
                        for signal_ref in reference_ids {
                            generator
                                .add_line()
                                .append(format!("{}: 0,", reference_counter(signal_ref)));
                        }
                    }
                }
            }
            generator
                .unindent()
                .add_line()
                .append("}".to_string())
                .unindent()
                .add_line()
                .append("}".to_string())
                .add_line()
                // Execution function
                .append(
                    "pub fn execute(&mut self, storage: &mut HashMap<String, Vec<String>>) {"
                        .to_string(),
                )
                .indent()
                .add_line();

            // Generate the actual execution implementation
            {
                generator.append(format!("println!(\"TODO: {}.execute()\");", node.id.rust()));
            }

            generator
                .unindent()
                .add_line()
                .append("}".to_string())
                .unindent()
                .add_line()
                .append("}".to_string());
        }
    }

    return generator.to_string();
}

fn signal() -> String {
    return String::new();
}

fn reference_counter(id: &nioe::ast::Identifier) -> String {
    return format!("{}_index", id.rust());
}
fn alias(node: &ast::Node) -> String {
    return format!("node_{}", node.id.rust());
}

pub fn execute(ast: &Ast) {
    let transpiled_code = generate(ast);
    let finalized_code = add_main(transpiled_code);
    write_to_disk(finalized_code);
}

fn output_queue(id: &String) -> String {
    return format!("{}_output_queue", id);
}

fn write_to_disk(code: String) {
    let component_path = format!("src/main.rs");

    let mut f = fs::File::create(component_path).unwrap();
    let mut file = LineWriter::new(f);

    file.write_all(code.as_bytes()).unwrap();

    file.flush().unwrap();
}
