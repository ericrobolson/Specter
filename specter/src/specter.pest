// Instead of directly using Rust, use this DSL as your language definition. 
// Then port to different platforms/focus on your DSL instead of a GPL.
// Keep it tight and focused.

// Reference https://pest.rs/#editor religiously.


// Types:
number = ${("-")? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)?}
vec2 = {^"vec2(" ~ number ~ "," ~ number ~ ")"}
vec3 = {^"vec3(" ~ number ~ ("," ~ number){2} ~ ")"}

stype = {number | vec2 | vec3}

identifier = @{ASCII_ALPHA ~ ASCII_ALPHANUMERIC*}
property = {"." ~ identifier}

component = {(^"component ") ~ identifier ~ "{"	~ ((identifier ~ ":" ~ identifier) ~ ("," ~ identifier ~ ":" ~ identifier)*)? ~ "}"}
component_def = {(component)*}

native_code = { (!^"end-native" ~ ANY)* } 
native_call = { ^"native" ~ native_code ~ ^"end-native" } 

// System definitions
system = {(^"system ") ~ identifier ~ "{" ~ system_component_join* ~ "}"}
system_component_join = {"(" ~ (system_component_alias ~ ("," ~ system_component_alias)*)? ~ ")" ~ "{" ~ expression* ~ "}"}
system_component_alias = {identifier ~ ":" ~ ("c" ~ "-w"? ~ ".") ~ identifier}

// Functions - Not sure these are even needed at this point. Could just get by with native stuff.
function = {^"fn " ~ identifier ~ "(" ~ (identifier ~ ("," ~ identifier)*)? ~ ")" ~ ":" ~ identifier ~ "{" ~ "}" }
function_call = {identifier ~ "(" ~ (function_arg ~ ("," ~ function_arg)*)? ~ ")"}
function_arg = {identifier ~ property?}


// Expressions and operations
term = {"(" ~ expression ~ ")" | function_call | (identifier ~ property?) }
operation = {"="}
expression = {(identifier ~ property) ~ (operation ~ (native_call | term))*}

// Specter keeps each file type separate; e.g. component definitions must be kept from system definitions
specter = {(component | system)+}


WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
